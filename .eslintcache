[{"/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/App.js":"1","/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/Pages/login.js":"2","/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/Pages/home.js":"3","/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/reportWebVitals.js":"4","/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/index.js":"5","/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/Components/navbar.js":"6"},{"size":536,"mtime":1607659130533,"results":"7","hashOfConfig":"8"},{"size":241,"mtime":1607114427653,"results":"9","hashOfConfig":"8"},{"size":4362,"mtime":1607633209407,"results":"10","hashOfConfig":"8"},{"size":362,"mtime":1607107045921,"results":"11","hashOfConfig":"8"},{"size":646,"mtime":1607107178724,"results":"12","hashOfConfig":"8"},{"size":570,"mtime":1607107587843,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"13h2t3h",{"filePath":"16","messages":"17","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"18","messages":"19","errorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"20"},{"filePath":"21","messages":"22","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"23","messages":"24","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/App.js",[],"/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/Pages/login.js",[],"/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/Pages/home.js",["27"],"import React, { useState, useEffect, useRef } from 'react';\nimport { Button, Form } from 'react-bootstrap/'\n\nexport const Home = () => {\n    \n    const [ position, setPosition ] = useState(0);\n    const [ delay, setDelay] = useState(1000)\n    const [ lyrics, setLyrics ] = useState(['hi']);\n    useEffect(() => {\n        if(position === lyrics.length){\n            setDelay(null)\n            setNewRace(false)\n            setStartRace(false)\n            setRaceCompleted(true)\n        }\n    },[position, lyrics])\n    const [ wordCount, setWordCount] = useState(0);\n    const [ startRace, setStartRace ] = useState(false);\n    const [ timer, setTimer ] = useState(0);\n    useInterval(() => {\n        if(startRace){\n            setTimer(timer + 1);\n        };\n    }, delay);\n    const [ newRace, setNewRace ] = useState(false);\n    const [ input, setInput ] = useState('');\n    const [ artist, setArtist ] = useState('');\n    const [ track, setTrack ] = useState('');\n    const [ raceCompleted, setRaceCompleted] = useState(false);\n    \n\n    const handleInput = (e) => {\n        setInput(e.target.value);\n        if( input === lyrics[position] ){\n            setWordCount((prev) => prev += lyrics[position].split(' ').length);\n            setPosition(position + 1);\n            setInput('');\n        };\n    }\n\n    const handleChange = (e) => {\n        e.target.name === 'artist' ? setArtist(e.target.value) : setTrack(e.target.value);\n    }\n\n    const handleSubmit = (e) => {\n        e.preventDefault()\n        fetch(`https://api.lyrics.ovh/v1/${artist}/${track}`)\n        .then(resp => resp.json())\n        .then(data => {\n            if(data.lyrics === \"\"){\n                return\n            };\n            const splitLyrics = data.lyrics.split(/\\r?\\n/).map(line => line.trim()).filter(line => line !== \"\");\n            setLyrics(splitLyrics);\n            setNewRace(false);\n            setStartRace(true);\n            setDelay(1000);\n        })\n    }\n\n    const reset = () => {\n        setPosition(0);\n        setWordCount(0);\n        setTimer(0);\n        setInput('');\n        setArtist('');\n        setTrack('');\n        setNewRace(false);\n        setLyrics(['hi']);\n        setStartRace(false);\n        setRaceCompleted(false);\n    }\n\n    const renderLines = () => {\n        let typedArray = []\n        lyrics.map((line, i) => {\n            if(position > i){\n                return typedArray.push(line)\n            }\n        })\n\n    return typedArray.map((line,i) => {\n        let name = i % 2 === 0 ? 'typed-line-right' : 'typed-line-left'\n        return <div className={name}>{line}</div>\n    })\n    }\n    \n\n    let wpm = Math.round((wordCount / timer) * 60) || \"\";\n    return(\n        <>\n        <div className='prev-words'>{renderLines()}</div>\n            { startRace ?\n            <>\n                <div className='words-to-type'>{lyrics[position]}\n                <Form className='typing-input'>\n                    <Form.Control size='lg' type='text' onChange={handleInput} value={input}/>\n                </Form>\n                </div>\n                <div>{wpm}</div>\n            </>\n                : newRace ?\n                <Form className='song-form' onSubmit={handleSubmit}>\n                    <Form.Control size='lg' onChange={handleChange} placeholder=\"Artist\" type='text' value={artist} name='artist'/>\n                    <Form.Control size='lg' onChange={handleChange} placeholder=\"Track\" type='text' value={track} name='track'/>\n                    <Button variant='dark' size='lg' type='submit'>Start</Button>\n                </Form>\n                    : raceCompleted ?\n                    <div> Nice, you just wrote out the song {track} by {artist} in {wpm} words per minute! <button onClick={reset}>reset</button></div>\n                        : <div className='race-btn'><Button size='lg' variant='dark' onClick={() => setNewRace(true)}>Start a new Race</Button></div>\n            }\n        </>\n    )\n}\n\nfunction useInterval(callback, delay) {\n  const savedCallback = useRef();\n\n  // Remember the latest callback.\n  useEffect(() => {\n    savedCallback.current = callback;\n  }, [callback]);\n\n  // Set up the interval.\n  useEffect(() => {\n    const tick = () => {\n      savedCallback.current();\n    }\n    if (delay !== null) {\n      let id = setInterval(tick, delay);\n      return () => clearInterval(id);\n    }\n  }, [delay]);\n}","/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/reportWebVitals.js",[],"/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/index.js",[],"/Users/anansi/Development/code/projects/typeracer/keyboardwarrior/src/Components/navbar.js",[],{"ruleId":"28","severity":1,"message":"29","line":76,"column":30,"nodeType":"30","messageId":"31","endLine":76,"endColumn":32},"array-callback-return","Array.prototype.map() expects a value to be returned at the end of arrow function.","ArrowFunctionExpression","expectedAtEnd"]